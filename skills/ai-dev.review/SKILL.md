---
name: ai-dev.review
description: 자동 검증 후 코드 리뷰를 수행하고 승인/변경요청을 결정합니다. "리뷰해줘", "코드 검토해줘" 요청 시 활성화. --full로 병렬 크로스체크.
---

# Skill: ai-dev.review

code-check와 work-check 결과를 종합하여 비즈니스 규칙을 검증하고 최종 승인/변경요청을 판정합니다.

**v5.0 변경사항**:
- 코드 품질 검증 → `ai-dev.code-check`로 분리
- 버그 탐지 → `ai-dev.work-check`로 분리
- 비즈니스 규칙 검증 + 최종 판정에 집중

---

## 목적

- code-check-report.md, work-check-report.md 결과 종합
- 비즈니스 규칙 검증 (상태 변수 영향도, 요구사항 역추적, 기능 충돌)
- 최종 승인/변경요청 판정

---

## 입력 (선행 조건)

| 파일 | 제공 스킬 | 필수 |
|------|----------|------|
| code-check-report.md | ai-dev.code-check | ✅ |
| work-check-report.md | ai-dev.work-check | ✅ |
| spec.md | ai-dev.spec | ⭕ (비즈니스 규칙 검증 시) |
| plan.md | ai-dev.plan | ⭕ |

---

## 사용 시점

- `/ai-dev.review PK-XXXXX` - 리뷰 시작
- `/ai-dev.review PK-XXXXX --full` - CodeRabbit + Codex 병렬 크로스체크
- ai-dev 파이프라인에서 `ai-dev.work-check` 완료 후 실행

---

## 워크플로우

```
┌─────────────────────────────────────────────────────────────────┐
│                    ai-dev.review 워크플로우 v5.0                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  [Step 0] 선행 검증 결과 로드                                     │
│  code-check-report.md + work-check-report.md                   │
│                                                                 │
│  [Step 1] 선행 검증 통과 확인                                     │
│  ├── code-check 등급: A/B → 통과, C/D → 중단                    │
│  └── work-check P0: 0건 → 통과, 1건+ → 중단                     │
│                                                                 │
│  [Step 2] 비즈니스 규칙 검증                                      │
│  ├── 상태 변수 영향도 분석                                        │
│  ├── 요구사항 역추적 (spec.md 있을 때)                            │
│  ├── 유사 패턴 비교                                               │
│  └── 기능 충돌 분석                                               │
│                                                                 │
│  [Step 3] 최종 판정                                               │
│  선행 검증 + 비즈니스 규칙 종합 → 승인/변경요청                     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## Step 0: 선행 검증 결과 로드

### 파일 경로

```
~/.claude/contexts/work/kidsnote/docs/ai-dev/{PK-xxxx}/
├── code-check-report.md  ← 품질 검증 결과
├── work-check-report.md  ← 버그 검사 결과
├── spec.md               ← 요구사항 (선택)
└── plan.md               ← 구현 계획 (선택)
```

### 로드 확인

```markdown
## 선행 검증 결과

| 리포트 | 상태 | 결과 |
|--------|------|------|
| code-check-report.md | ✅/❌ | 등급: {A/B/C/D} |
| work-check-report.md | ✅/❌ | P0: {N}건, P1: {N}건 |
```

---

## Step 1: 선행 검증 통과 확인

### 통과 조건

| 검증 | 통과 조건 | 중단 조건 |
|------|----------|----------|
| code-check | 등급 A 또는 B | 등급 C 또는 D |
| work-check | P0 = 0건 | P0 ≥ 1건 |

### 중단 시 처리

```markdown
## ❌ 선행 검증 미통과

**code-check**: 등급 {등급}
**work-check**: P0 {N}건

### 필수 조치
1. [ ] code-check C/D 등급 → 품질 이슈 수정 후 `/ai-dev.code-check` 재실행
2. [ ] work-check P0 → 버그 수정 후 `/ai-dev.work-check` 재실행

**리뷰 중단**. 선행 검증 통과 후 다시 실행하세요.
```

---

## Step 2: 비즈니스 규칙 검증

> **목적**: CodeRabbit/정적분석이 놓치는 비즈니스 로직 오류 탐지

`--no-biz-rules` 옵션 사용 시 이 단계를 스킵합니다.

### Step 2.1: 상태 변수 영향도 분석

**실행 조건**: 변경된 코드에 상태 변수(`is*`, `has*`, `should*`) 할당이 포함된 경우

**검증 방법**:
```bash
# 1. 변경 파일에서 상태 변수 추출
git diff HEAD~1 | grep -E "^\+.*is[A-Z]|^\+.*has[A-Z]|^\+.*should[A-Z]"

# 2. 해당 변수의 전체 사용 패턴 분석
Grep: "{변수명}\s*=" --type swift --output_mode content
Grep: "if.*{변수명}|guard.*{변수명}" --type swift --output_mode content
```

**출력**:
```markdown
### 상태 변수: {변수명}

**용도**: {비즈니스 의미}
**할당점**: {N}개
**검사점**: {M}개

**새 코드 검증**:
- [ ] 적절한 할당
- [ ] 적절한 검사
- [ ] 기존 규칙 준수

**위험 평가**: 🔴 높음 / 🟠 중간 / 🟢 낮음
```

### Step 2.2: 요구사항 역추적

**실행 조건**: spec.md가 존재하는 경우

**검증 체크리스트**:
```markdown
### 요구사항 역추적

| # | 요구사항 | spec.md 섹션 | 구현 파일 | 상태 |
|---|---------|-------------|----------|------|
| 1 | {요구사항} | {섹션} | {파일} | ✅/❌ |

**누락된 요구사항**:
- ❌ {요구사항}: {구현 누락 이유}
```

### Step 2.3: 유사 패턴 비교

**실행 조건**: 새로운 함수/메서드 추가 또는 기존 함수 변형 시

**검증 항목**:
- 초기화 순서 일관성
- 상태 검사 로직 일관성
- 에러 핸들링 패턴 일관성

### Step 2.4: 기능 충돌 분석

**실행 조건**: 상태 변수 변경 또는 새로운 진입점 추가 시

**검증 시나리오**:
```markdown
### 기능 충돌 분석

| 기존 기능/모드 | 충돌 가능성 | 영향 | 권장 조치 |
|---------------|------------|------|----------|
| {모드명} | 🔴/🟠/🟢 | {영향} | {조치} |

**충돌 시나리오**:
1. 전제조건: {모드} = {상태}
2. 사용자 액션: {액션}
3. 기대 결과: {기존 규칙}
4. 실제 결과: {새 코드 동작}
5. 충돌 여부: ✅/❌
```

### Step 2.5: Figma 시각적 검증 (UI 변경 시)

**실행 조건**: Figma URL이 있고 UI 관련 변경이 포함된 경우

**figma-ocaml MCP로 검증:**

```
# 1. 구현 스크린샷 vs 디자인 비교
mcp__figma-ocaml__figma_image_similarity(
  file_key: "{file_key}",
  node_id: "{node_id}",
  token: "{FIGMA_TOKEN}",
  screenshot_path: "{구현 스크린샷 경로}"
)

# 2. 상세 시각적 검증 (필요 시)
mcp__figma-ocaml__figma_verify_visual(
  file_key: "{file_key}",
  node_id: "{node_id}",
  token: "{FIGMA_TOKEN}",
  screenshot_path: "{구현 스크린샷 경로}",
  target_ssim: 0.95
)

# 3. 영역별 비교 (불일치 시)
mcp__figma-ocaml__figma_compare_regions(
  file_key: "{file_key}",
  node_id: "{node_id}",
  token: "{FIGMA_TOKEN}",
  screenshot_path: "{구현 스크린샷 경로}"
)
```

**검증 기준:**

| SSIM | 판정 | 조치 |
|------|------|------|
| 95%+ | ✅ 통과 | - |
| 90-95% | ⚠️ 경미한 차이 | 리포트에 기록 |
| 90% 미만 | ❌ 수정 필요 | 필수 수정 항목 |

**출력:**
```markdown
### Figma 시각적 검증

| 화면 | SSIM | 상태 | 비고 |
|------|------|------|------|
| {화면명} | 97.2% | ✅ 통과 | - |
| {화면명} | 91.5% | ⚠️ 경미 | 색상 미세 차이 |

**불일치 상세** (90% 미만 시):
- 영역: {영역}
- 디자인: {Figma 값}
- 구현: {실제 값}
- 수정 제안: {수정 방법}
```

---

## Step 3: 최종 판정

### 판정 기준

| 조건 | 결과 |
|------|------|
| 선행 검증 통과 + 비즈니스 규칙 통과 | ✅ 승인 |
| 선행 검증 통과 + 비즈니스 규칙 경미한 이슈 | ⚠️ 조건부 승인 |
| 선행 검증 미통과 또는 Critical 비즈니스 이슈 | ❌ 변경요청 |

### 심각도 분류

| 심각도 | 설명 | 조치 |
|--------|------|------|
| 🔴 Critical | 비즈니스 규칙 위반 | 머지 전 필수 수정 |
| 🟠 High | 잠재적 충돌 | 수정 강력 권장 |
| 🟡 Medium | 개선 권장 | 다음 버전에서 개선 |
| 🟢 Low | 참고 | 선택적 개선 |

---

## 출력 템플릿

```markdown
# {TICKET_ID} 코드 리뷰 결과

**리뷰일**: YYYY-MM-DD HH:MM
**티켓**: {TICKET_ID} - {제목}

---

## 선행 검증 결과

| 검증 | 결과 | 상세 |
|------|------|------|
| code-check | 등급 {등급} | DRY ✅, SOLID ⚠️, Complexity ✅ |
| work-check | P0: {N}건 | 버그 {총}건 발견 |

**선행 검증**: ✅ 통과 / ❌ 미통과

---

## 비즈니스 규칙 검증

### 상태 변수 영향도
| 변수명 | 할당점 | 기존 규칙 | 새 코드 | 결과 |
|--------|--------|----------|---------|------|
| {변수} | {N}개 | {규칙} | {상태} | ✅/❌ |

### 요구사항 역추적
| 요구사항 | spec.md | 구현 상태 | 결과 |
|----------|---------|----------|------|
| {항목} | ✅ | ✅/❌ | ✅/❌ |

### 기능 충돌 분석
| 기존 기능/모드 | 충돌 가능성 | 영향 |
|---------------|------------|------|
| {기능} | 🔴/🟠/🟢 | {영향} |

### Figma 시각적 검증 (UI 변경 시)
| 화면 | SSIM | 상태 | 비고 |
|------|------|------|------|
| {화면명} | 97.2% | ✅ 통과 | - |

---

## 최종 판정

| 항목 | 결과 |
|------|------|
| **판정** | ✅ 승인 / ⚠️ 조건부 승인 / ❌ 변경요청 |
| 선행 검증 | ✅ 통과 |
| 비즈니스 규칙 | ✅ 통과 / ⚠️ 경미한 이슈 / ❌ Critical |

---

## 액션 아이템

### 필수 (Blocking)
1. [ ] {항목}

### 권장 (Non-blocking)
1. [ ] {항목}

---

## 다음 단계

- ✅ 승인: `/ai-dev.pr PK-XXXXX` 진행
- ⚠️ 조건부 승인: 권장 조치 검토 후 진행 결정
- ❌ 변경요청: 필수 조치 완료 후 재리뷰

---

*Reviewed by ai-dev.review v5.0*
```

---

## 옵션

| 옵션 | 설명 |
|------|------|
| `--full` | CodeRabbit + Codex MCP 병렬 크로스체크 |
| `--no-biz-rules` | 비즈니스 규칙 검증 비활성화 |
| `--quick` | 빠른 리뷰 (선행 검증 확인 + 최종 판정만) |

### 사용 예시

```bash
# 기본 (비즈니스 규칙 검증 포함)
/ai-dev.review PK-32398

# 전체 검증 + 크로스체크
/ai-dev.review PK-32398 --full

# 빠른 리뷰 (긴급 핫픽스)
/ai-dev.review PK-32398 --quick

# 비즈니스 규칙 검증 제외
/ai-dev.review PK-32398 --no-biz-rules
```

---

## --full 옵션: 크로스체크

### CodeRabbit AI 리뷰

```bash
coderabbit review --plain -t all
```

### Codex MCP 크로스체크

```
mcp__codex__codex(
  prompt: "다음 파일들의 코드 변경사항을 빠르게 스캔해주세요:
1. 보안 취약점
2. 성능 안티패턴
3. 코드 품질 이슈

변경 파일: {파일 목록}

각 이슈를 Critical/High/Medium/Low로 분류해주세요.",
  cwd: "{프로젝트 경로}",
  approval-policy: "on-failure",
  sandbox: "read-only"
)
```

### 크로스체크 종합

| 동의 수준 | 판정 |
|----------|------|
| 3/3 동의 | 확정 이슈 |
| 2/3 동의 | 높은 가능성 |
| 1/3만 지적 | 검토 필요 |

---

## 연계 스킬

| 스킬 | 용도 | 순서 |
|------|------|------|
| `/ai-dev.code-check` | 선행 (품질 검증) | Phase 3.5 |
| `/ai-dev.work-check` | 선행 (버그 검사) | Phase 3.8 |
| `/ai-dev.pr` | 후속 (PR 생성) | Phase 5 |
| `/codex-hotfix` | 발견된 이슈 빠른 수정 | - |

---

**Created:** 2026-01-23
**Updated:** 2026-01-28
**Version:** 5.0 (code-check, work-check 분리에 따른 간소화)
